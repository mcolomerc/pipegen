package cmd

import (
	"bytes"
	"context"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/spf13/cobra"
	"github.com/stretchr/testify/require"
)

const sampleAVSC = `{
  "type": "record",
  "name": "UserEvent",
  "namespace": "com.example",
  "fields": [
    {"name": "user_id", "type": "string"},
    {"name": "amount", "type": "double"},
    {"name": "ts", "type": {"type":"long", "logicalType":"timestamp-millis"}}
  ]
}`

// quickOllamaCheck tries to check if Ollama is reachable; returns false quickly if not
func quickOllamaCheck() bool {
	base := os.Getenv("PIPEGEN_OLLAMA_URL")
	if base == "" {
		base = "http://localhost:11434"
	}
	// Only attempt if a model is configured or default reachable
	if os.Getenv("PIPEGEN_OLLAMA_MODEL") == "" {
		return false
	}
	ctx, cancel := context.WithTimeout(context.Background(), 1500*time.Millisecond)
	defer cancel()
	req, _ := http.NewRequestWithContext(ctx, http.MethodGet, base+"/api/tags", nil)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return false
	}
	_ = resp.Body.Close()
	return resp.StatusCode >= 200 && resp.StatusCode < 500
}

func TestInitWithAVSC_NoDescribe_GeneratesBaselineDDL(t *testing.T) {
	tmp := t.TempDir()
	cwd, _ := os.Getwd()
	defer func() { _ = os.Chdir(cwd) }()
	require.NoError(t, os.Chdir(tmp))

	// Create sample AVSC file
	avscPath := filepath.Join(tmp, "input.avsc")
	require.NoError(t, os.WriteFile(avscPath, []byte(sampleAVSC), 0644))

	// Prepare command with flags expected by runInit
	c := &cobra.Command{Use: "init"}
	c.Flags().Bool("force", true, "")
	c.Flags().String("input-schema", avscPath, "")
	c.Flags().String("describe", "", "")
	c.Flags().String("domain", "", "")

	// Ensure flags are set for Get* calls inside runInit
	require.NoError(t, c.Flags().Set("force", "true"))
	require.NoError(t, c.Flags().Set("input-schema", avscPath))

	project := "e2e-no-describe"
	err := runInit(c, []string{project})
	require.NoError(t, err)

	// Verify project files
	projDir := filepath.Join(tmp, project)
	inSchema := filepath.Join(projDir, "schemas", "input.avsc")
	content, err := os.ReadFile(inSchema)
	require.NoError(t, err)
	require.Contains(t, string(content), "UserEvent")

	// Baseline DDL should be synthesized
	ddl := filepath.Join(projDir, "sql", "01_create_source_table.sql")
	ddlBytes, err := os.ReadFile(ddl)
	require.NoError(t, err)
	require.Contains(t, string(ddlBytes), "CREATE TABLE")
	require.Contains(t, string(ddlBytes), "avro-confluent")
}

func TestInitWithAVSC_AndDescribe_UsesOllamaIfAvailable(t *testing.T) {
	// Only run if Ollama is configured and reachable; otherwise skip to avoid network in CI
	if !quickOllamaCheck() {
		t.Skip("Ollama not configured or unreachable; set PIPEGEN_OLLAMA_MODEL and run local Ollama to enable this E2E test")
	}

	tmp := t.TempDir()
	cwd, _ := os.Getwd()
	defer func() { _ = os.Chdir(cwd) }()
	require.NoError(t, os.Chdir(tmp))

	// Create sample AVSC file
	avscPath := filepath.Join(tmp, "input.avsc")
	require.NoError(t, os.WriteFile(avscPath, []byte(sampleAVSC), 0644))

	// Prepare command
	c := &cobra.Command{Use: "init"}
	c.Flags().Bool("force", true, "")
	c.Flags().String("input-schema", avscPath, "")
	c.Flags().String("describe", "aggregate spend per user", "")
	c.Flags().String("domain", "ecommerce", "")

	require.NoError(t, c.Flags().Set("force", "true"))
	require.NoError(t, c.Flags().Set("input-schema", avscPath))
	require.NoError(t, c.Flags().Set("describe", "aggregate spend per user"))
	require.NoError(t, c.Flags().Set("domain", "ecommerce"))

	// Minimal env for Ollama provider
	// Note: if PIPEGEN_OLLAMA_MODEL isn't set, quickOllamaCheck would have skipped already
	// Keep any user-provided PIPEGEN_OLLAMA_URL as-is

	project := "e2e-with-describe"
	// Constrain test with a shorter overall timeout to avoid long hangs
	done := make(chan error, 1)
	go func() { done <- runInit(c, []string{project}) }()

	select {
	case err := <-done:
		require.NoError(t, err)
	case <-time.After(60 * time.Second):
		t.Fatal("init with Ollama timed out")
	}

	projDir := filepath.Join(tmp, project)
	// Check schema is written from provided AVSC
	inSchema := filepath.Join(projDir, "schemas", "input.avsc")
	b, err := os.ReadFile(inSchema)
	require.NoError(t, err)
	require.Contains(t, string(b), "UserEvent")

	// Ensure at least one SQL file exists and likely contains AI header
	sqlDir := filepath.Join(projDir, "sql")
	var foundAI bool
	_ = filepath.WalkDir(sqlDir, func(path string, d fs.DirEntry, err error) error {
		if err == nil && !d.IsDir() && filepath.Ext(path) == ".sql" {
			data, _ := os.ReadFile(path)
			if bytes.Contains(data, []byte("Generated by PipeGen AI")) || bytes.Contains(data, []byte("CREATE TABLE")) {
				foundAI = true
			}
		}
		return nil
	})
	require.True(t, foundAI, "expected at least one generated SQL file")
}

func TestInitDescribeWithoutAI_FallbacksToMinimal(t *testing.T) {
	// Ensure AI is disabled
	_ = os.Unsetenv("PIPEGEN_OPENAI_API_KEY")
	_ = os.Unsetenv("PIPEGEN_OLLAMA_MODEL")
	_ = os.Unsetenv("PIPEGEN_OLLAMA_URL")

	tmp := t.TempDir()
	cwd, _ := os.Getwd()
	defer func() { _ = os.Chdir(cwd) }()
	require.NoError(t, os.Chdir(tmp))

	// Create sample AVSC file
	avscPath := filepath.Join(tmp, "input.avsc")
	require.NoError(t, os.WriteFile(avscPath, []byte(sampleAVSC), 0644))

	c := &cobra.Command{Use: "init"}
	c.Flags().Bool("force", true, "")
	c.Flags().String("input-schema", avscPath, "")
	c.Flags().String("describe", "pipeline from avsc", "")
	c.Flags().String("domain", "ecommerce", "")

	require.NoError(t, c.Flags().Set("force", "true"))
	require.NoError(t, c.Flags().Set("input-schema", avscPath))
	require.NoError(t, c.Flags().Set("describe", "pipeline from avsc"))
	require.NoError(t, c.Flags().Set("domain", "ecommerce"))

	project := "e2e-fallback-no-ai"
	err := runInit(c, []string{project})
	require.NoError(t, err)

	projDir := filepath.Join(tmp, project)
	// Input schema should be used and copied
	inSchema := filepath.Join(projDir, "schemas", "input.avsc")
	b, err := os.ReadFile(inSchema)
	require.NoError(t, err)
	require.Contains(t, string(b), "UserEvent")

	// Baseline DDL should be synthesized in fallback
	ddl := filepath.Join(projDir, "sql", "01_create_source_table.sql")
	ddlBytes, err := os.ReadFile(ddl)
	require.NoError(t, err)
	require.Contains(t, string(ddlBytes), "CREATE TABLE")
}

func TestInitNoSchema_NoAI_MinimalGeneration(t *testing.T) {
	// Ensure AI is disabled
	_ = os.Unsetenv("PIPEGEN_OPENAI_API_KEY")
	_ = os.Unsetenv("PIPEGEN_OLLAMA_MODEL")
	_ = os.Unsetenv("PIPEGEN_OLLAMA_URL")

	tmp := t.TempDir()
	cwd, _ := os.Getwd()
	defer func() { _ = os.Chdir(cwd) }()
	require.NoError(t, os.Chdir(tmp))

	c := &cobra.Command{Use: "init"}
	c.Flags().Bool("force", true, "")
	c.Flags().String("input-schema", "", "")
	c.Flags().String("describe", "please generate", "")
	c.Flags().String("domain", "", "")

	require.NoError(t, c.Flags().Set("force", "true"))
	require.NoError(t, c.Flags().Set("describe", "please generate"))

	project := "e2e-minimal-no-ai"
	err := runInit(c, []string{project})
	require.NoError(t, err)

	projDir := filepath.Join(tmp, project)
	// Default schema should be generated
	inSchema := filepath.Join(projDir, "schemas", "input.avsc")
	b, err := os.ReadFile(inSchema)
	require.NoError(t, err)
	require.Contains(t, string(b), "type")

	// Source table may or may not be synthesized depending on default template;
	// we assert the sql directory exists at minimum
	_, err = os.Stat(filepath.Join(projDir, "sql"))
	require.NoError(t, err)
}
